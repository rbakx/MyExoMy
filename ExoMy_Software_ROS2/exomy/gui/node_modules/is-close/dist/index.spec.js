"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
require("mocha");
var index_1 = require("./index");
describe('isClose function test', function () {
    it('should return true for identical values', function () {
        var result = index_1.isClose(1.0, 1.0);
        chai_1.expect(result).to.equal(true);
    });
    it('should return false for two NaNs', function () {
        var result = index_1.isClose(NaN, NaN);
        chai_1.expect(result).to.equal(false);
    });
    it('should return true for two NaNs when equalNaN is true', function () {
        var result = index_1.isClose(NaN, NaN, undefined, undefined, true);
        chai_1.expect(result).to.equal(true);
    });
    it('should return true when absolute tolerance is met', function () {
        var result = index_1.isClose(100000, 100001, 0, 1);
        chai_1.expect(result).to.equal(true);
    });
    it('should return false when absolute tolerance is breached', function () {
        var result = index_1.isClose(100000, 100001.00000001, 0, 1);
        chai_1.expect(result).to.equal(false);
    });
    it('should return true when one value is 0 and the other -0', function () {
        var result = index_1.isClose(-0, 0);
        chai_1.expect(result).to.equal(true);
    });
    it('should return true when both values are Infinity', function () {
        var result = index_1.isClose(Infinity, Infinity);
        chai_1.expect(result).to.equal(true);
    });
    it('should return false when one value is Infinity and the other is -Infinity', function () {
        var result = index_1.isClose(Infinity, -Infinity);
        chai_1.expect(result).to.equal(false);
    });
    it('should return false when one value is Infinity and the other MAX_VALUE', function () {
        var result = index_1.isClose(Infinity, Number.MAX_VALUE);
        chai_1.expect(result).to.equal(false);
    });
    it('should return false when one value is Infinity and the other -MAX_VALUE', function () {
        var result = index_1.isClose(-Infinity, -Number.MAX_VALUE);
        chai_1.expect(result).to.equal(false);
    });
    describe('calculate relative difference using largest of a and b in magnitude - |a-b|/max(|a|,|b|)', function () {
        it('should return true for slightly different values', function () {
            var result = index_1.isClose(1.0, 1.0000000001);
            chai_1.expect(result).to.equal(true);
        });
        it('should return false for sufficiently different values', function () {
            var result = index_1.isClose(1.0, 1.000000001);
            chai_1.expect(result).to.equal(false);
        });
        it('should return true for slightly different large values', function () {
            var result = index_1.isClose(1e10, 1.0000000001e10);
            chai_1.expect(result).to.equal(true);
        });
        it('should return false for different small values', function () {
            var result = index_1.isClose(1e-7, 1e-8);
            chai_1.expect(result).to.equal(false);
        });
        it('should return true when relative tolerance is met', function () {
            var result = index_1.isClose(1111.1111111111111, 1000, 0.1, 0);
            chai_1.expect(result).to.equal(true);
        });
        it('should return false when relative tolerance is breached', function () {
            var result = index_1.isClose(1111.1111111111112, 1000, 0.1, 0);
            chai_1.expect(result).to.equal(false);
        });
    });
    describe('calculate relative error using a as theoretical value  - |a-b|/|a|', function () {
        it('should return true when relative tolerance is met (above)', function () {
            var result = index_1.isClose(1000, 1010, 0.01, 0, undefined, index_1.IsCloseScalers.absA);
            chai_1.expect(result).to.equal(true);
        });
        it('should return false when relative tolerance is breached (above)', function () {
            var result = index_1.isClose(1000, 1010.0000000000001, 0.01, 0, undefined, index_1.IsCloseScalers.absA);
            chai_1.expect(result).to.equal(false);
        });
        it('should return true when relative tolerance is met (below)', function () {
            var result = index_1.isClose(1000, 990, 0.01, 0, undefined, index_1.IsCloseScalers.absA);
            chai_1.expect(result).to.equal(true);
        });
        it('should return false when relative tolerance is breached (below)', function () {
            var result = index_1.isClose(1000, 989.9999999999999, 0.01, 0, undefined, index_1.IsCloseScalers.absA);
            chai_1.expect(result).to.equal(false);
        });
    });
    describe('calculate relative error using b as theoretical value - |a-b|/|b|', function () {
        it('should return true when relative tolerance is met (above)', function () {
            var result = index_1.isClose(1010, 1000, 0.01, 0, undefined, index_1.IsCloseScalers.absB);
            chai_1.expect(result).to.equal(true);
        });
        it('should return false when relative tolerance is breached (above)', function () {
            var result = index_1.isClose(1010.0000000000001, 1000, 0.01, 0, undefined, index_1.IsCloseScalers.absB);
            chai_1.expect(result).to.equal(false);
        });
        it('should return true when relative tolerance is met (below)', function () {
            var result = index_1.isClose(990, 1000, 0.01, 0, undefined, index_1.IsCloseScalers.absB);
            chai_1.expect(result).to.equal(true);
        });
        it('should return false when relative tolerance is breached (below)', function () {
            var result = index_1.isClose(989.9999999999999, 1000, 0.01, 0, undefined, index_1.IsCloseScalers.absB);
            chai_1.expect(result).to.equal(false);
        });
    });
    describe('compute closeness for arrays', function () {
        it('should return [true, false] when two arrays with appropriate values is supplied', function () {
            var result = index_1.isClose([1, 1], [1.0000000001, 1.000000001]);
            chai_1.expect(result.length).to.equal(2);
            chai_1.expect(result[0]).to.equal(true);
            chai_1.expect(result[1]).to.equal(false);
        });
        it('should return [true, false, undefined] when two different sized  with appropriate values is supplied', function () {
            var result = index_1.isClose([1e10, 1e-7, 2], [1.0000000001e10, 1e-8]);
            chai_1.expect(result.length).to.equal(3);
            chai_1.expect(result[0]).to.equal(true);
            chai_1.expect(result[1]).to.equal(false);
            chai_1.expect(result[2]).to.equal(undefined);
        });
        it('should return [true, false, undefined] when two different sized arrays with appropriate values is supplied', function () {
            var result = index_1.isClose([1e-7, 1e10], [1e-8, 1.0000000001e10, 1]);
            chai_1.expect(result.length).to.equal(3);
            chai_1.expect(result[0]).to.equal(false);
            chai_1.expect(result[1]).to.equal(true);
            chai_1.expect(result[2]).to.equal(undefined);
        });
    });
});
